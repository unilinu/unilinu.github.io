### 参考文献

- [TLPI](./TLPI.MD)
- [APUE](./APUE.MD)

### [系统调用和库函数调用](https://blog.csdn.net/sinat_36053757/article/details/78171620)

- [Linux syscall过程分析（万字长文）](https://cloud.tencent.com/developer/article/1492374)

### [进程和线程](https://blog.csdn.net/ThinkWon/article/details/102021274)

- 进程

  一个在内存中运行的应用程序。每个进程都有自己独立的一块内存空间，一个进程可以有多个线程

- 线程

  进程中的一个执行任务（控制单元），负责当前进程中程序的执行。一个进程至少有一个线程，一个进程可以运行多个线程，多个线程可共享数据。

  与进程不同的是同类的多个线程共享进程的**堆**和**方法区**资源，但每个线程有自己的**程序计数器**、**虚拟机栈**和**本地方法栈**，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。

- 区别

  线程具有许多传统进程所具有的特征，故又称为轻型进程(Light-Weight Process)或进程元；而把传统的进程称为重型进程(Heavy-Weight Process)，它相当于只有一个线程的任务。在引入了线程的操作系统中，通常一个进程都有若干个线程，至少包含一个线程。

  * **根本区别**：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位

  - 资源开销：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。
  - 包含关系：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。
  - 内存分配：同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的
  - ?影响关系?：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。
  - 执行过程：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行

### [进程同步](https://github.com/CyC2018/CS-Notes)

- 临界区

  对临界资源进行访问的那段代码称为临界区。

  为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。

- 同步与互斥
  - 同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。
  - 互斥：多个进程在同一时刻只有一个进程能进入临界区。

#### 1. 信号量

信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。

down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。

如果信号量的取值只能为 0 或者 1，那么就成为了 **互斥量（Mutex）** ，0 表示临界区已经加锁，1 表示临界区解锁。

**使用信号量实现生产者-消费者问题**

#### 2. 管程

使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。

### 进程间通信

#### 1. 管道

管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。

它具有以下限制：

- 只支持半双工通信（单向交替传输）；
- 只能在父子进程或者兄弟进程中使用。

#### 2. FIFO

也称为命名管道，去除了管道只能在父子进程中使用的限制。

FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。

#### 3. 消息队列

相比于 FIFO，消息队列具有以下优点：

- 消息队列可以**独立于读写进程存在**，从而避免了 FIFO 中**同步管道的打开和关闭**时可能产生的困难；
- 避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；
- 读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。

#### 4. 信号量

它是一个计数器，用于为多个进程提供对共享数据对象的访问。

#### 5. 共享存储

允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。

需要使用信号量用来同步对共享存储的访问。

多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用内存的匿名段。

#### 6. 套接字

与其它通信机制不同的是，它可用于不同机器间的进程通信。

### 并发和并行



![img](https://paul-pub.oss-cn-beijing.aliyuncs.com/2019/2019-11-26-cpp-concurrency/con_and_par.jpg)

- **并发**：如果多个队列可以交替使用某台咖啡机，则这一行为就是并发的。
- **并行**：如果存在多台咖啡机可以被多个队列交替使用，则就是并行。


- 更严格的来说：如果一个系统支持多个动作同时存在，那么这个系统就是一个并发系统。如果这个系统还支持多个动作（物理时间上）同时执行，那么这个系统就是一个并行系统。

### [I/O - 同步和异步 VS 阻塞和非阻塞](https://www.cnblogs.com/loveer/p/11479249.html)

TODO：

- https://www.jianshu.com/p/486b0965c296
- https://zhuanlan.zhihu.com/p/115912936
- https://segmentfault.com/a/1190000003063859
- [epoll](https://blog.csdn.net/daaikuaichuan/article/details/83862311)

> 妈妈让我去厨房烧一锅水，准备下饺子
> 阻塞：水只要没烧开，我就干瞪眼看着这个锅，沧海桑田，日新月异，我自岿然不动，厨房就是我的家，烧水是我的宿命。
>
> 非阻塞：我先去我屋子里打把王者，但是每过一分钟，我都要去厨房瞅一眼，生怕时间长了，水烧干了就坏了，这样导致我游戏没心思打，果不然，又掉段了。
>
> 同步：不管是每分钟过来看一眼锅，还是寸步不离的一直看着锅，**只要我不去看，我就不知道水烧好没有**，浪费时间啊，一寸光阴一寸金，这锅必须发我13薪
>
> 异步：我在淘宝买了一个电水壶，只要**打开开关，我就先不用管了，水开了，它就发出响声**，嗨呀，可以安心打王者喽，打完可以吃饺子喽~
>
> 总结：
> 阻塞/非阻塞：我在等你干活的时候我在干啥？
> 阻塞：啥也不干，死等
> 非阻塞：可以干别的，但也要时不时问问你的进度
> 同步/异步：你干完了，怎么让我知道呢？
> 同步：我只要不问，你就不告诉我
> 异步：你干完了，直接喊我过来就行

- 同步和异步

  同步和异步关注的是**消息通信机制** (synchronous communication/ asynchronous communication)
  所谓同步，就是在发出一个*调用*时，在没有得到结果之前，该*调用*就不返回。但是一旦调用返回，就得到返回值了。
  换句话说，就是由*调用者*主动等待这个*调用*的结果。

  而异步则是相反，**调用在发出之后，这个调用就直接返回了，所以没有返回结果**。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在*调用*发出后，*被调用者*通过状态、通知来通知调用者，或通过回调函数处理这个调用。

  典型的异步编程模型比如Node.js

- 阻塞和非阻塞

  阻塞和非阻塞关注的是**程序在等待调用结果（消息，返回值）时的状态.**

  阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。
  非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。

![模型比较](https://img2018.cnblogs.com/blog/1748170/201909/1748170-20190906210650873-272348693.png)

![异步IO](https://img2018.cnblogs.com/blog/1748170/201909/1748170-20190906211421376-2097741161.png)

![img](https://img2018.cnblogs.com/blog/1748170/201909/1748170-20190906211429619-939802087.png)

![img](https://img2018.cnblogs.com/blog/1748170/201909/1748170-20190906211436023-1996044746.png)